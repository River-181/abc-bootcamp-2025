# 아두이노-앱 실시간 연동 아키텍처 (WebSocket 활용)

아두이노(ESP32)와 사용자 앱을 1:1로 안정적으로 연결하여 실시간 데이터를 주고받기 위한 시스템 구축 계획입니다. 핵심은 서버가 특정 기기와 특정 앱을 짝지어주는 '매치메이커' 역할을 수행하는 것입니다.

### 핵심 아키텍처: '매치메이킹' 서버

서버는 단순히 메시지를 전체에 방송하는 것을 넘어, 어떤 기기와 어떤 앱이 짝꿍인지를 기억하고, 그들 사이에서만 메시지를 전달하는 '교환원' 역할을 해야 합니다.

```
+-------------+                           +-------------------------+                           +-----------------+
| 사용자 앱 A | <--- (WebSocket Conn A) --- |                         | --- (WebSocket Conn 1) ---> |    ESP32 #1     |
+-------------+                           |                         |                           +-----------------+
                                          |   백엔드 서버           |
                                          | (기기-앱 매칭 & 중계)   |
+-------------+                           |                         |                           +-----------------+
| 사용자 앱 B | <--- (WebSocket Conn B) --- |                         | --- (WebSocket Conn 2) ---> |    ESP32 #2     |
+-------------+                           +-------------------------+                           +-----------------+
```

---

### 개발 실행 계획 (3단계)

#### 1단계: '매치메이킹' 웹소켓 서버 구축 (Node.js)

서버는 각 연결이 '기기'인지 '앱'인지, 그리고 누구의 짝인지 알아야 합니다. 이를 위해 간단한 등록 절차를 추가합니다.

*   **`server.js` (업그레이드 버전):**

    ```javascript
    const WebSocket = require('ws');
    const wss = new WebSocket.Server({ port: 8080 });

    // 연결된 클라이언트들을 저장할 객체
    const clients = {}; // 예: { "device-001": ws, "app-001": ws }
    const pairs = {};   // 예: { "device-001": "app-001", "app-001": "device-001" }

    console.log("Smart WebSocket server started on port 8080");

    wss.on('connection', ws => {
        console.log('Client connected');

        ws.on('message', message => {
            const data = JSON.parse(message);

            // 1. 등록 메시지 처리
            if (data.type === 'register') {
                const { id, pairWith } = data;
                console.log(`Registering: ${id} paired with ${pairWith}`);
                ws.id = id; // 웹소켓 객체에 id를 저장
                clients[id] = ws;
                pairs[id] = pairWith;
                ws.send(JSON.stringify({ type: 'status', message: 'Registered successfully!' }));
                return;
            }

            // 2. 데이터 메시지 중계
            const senderId = ws.id;
            const recipientId = pairs[senderId];
            const recipientWs = clients[recipientId];

            if (recipientWs && recipientWs.readyState === WebSocket.OPEN) {
                console.log(`Relaying message from ${senderId} to ${recipientId}`);
                recipientWs.send(message.toString());
            }
        });

        ws.on('close', () => {
            console.log(`Client ${ws.id} disconnected`);
            // 연결이 끊기면 저장된 정보에서 삭제
            const pairId = pairs[ws.id];
            delete clients[ws.id];
            delete pairs[ws.id];
            delete pairs[pairId];
        });
    });
    ```

#### 2단계: ESP32 코드 - '자신을 등록하는' 기능 추가

ESP32는 이제 서버에 연결할 때, 자신의 고유 ID와 연결되기를 원하는 앱의 ID를 알려줘야 합니다.

*   **ESP32 코드 (업그레이드 버전):**

    ```cpp
    #include <ArduinoWebsockets.h>
    #include <WiFi.h>

    const char* ssid = "YOUR_WIFI_SSID";
    const char* password = "YOUR_WIFI_PASSWORD";
    const char* websocket_server_host = "YOUR_SERVER_IP";
    const uint16_t websocket_server_port = 8080;

    // 이 기기의 고유 ID와, 이 기기와 페어링될 앱의 ID
    const char* DEVICE_ID = "device-001";
    const char* APP_ID_TO_PAIR = "app-001";

    using namespace websockets;
    WebsocketsClient client;

    // 서버에 연결되었을 때 호출될 함수
    void onConnected(WebsocketsEvent event, String data) {
      if (event == WebsocketsEvent::ConnectionOpened) {
        Serial.println("WebSocket Connected!");
        // 서버에 등록 메시지 전송
        String register_msg = "{\"type\":\"register\", \"id\":\"" + String(DEVICE_ID) + "\", \"pairWith\":\"" + String(APP_ID_TO_PAIR) + "\"}";
        client.send(register_msg);
      }
    }

    void setup() {
      Serial.begin(115200);
      WiFi.begin(ssid, password);
      while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print("."); }
      Serial.println(" WiFi Connected");

      // 연결 이벤트 핸들러 등록
      client.onEvent(onConnected);
      client.connect(websocket_server_host, websocket_server_port, "/");
    }

    void loop() {
      if(client.available()) {
        client.poll(); // 이벤트 리스너를 계속 확인
        int magnitude = random(0, 100);
        String json_data = "{\"type\":\"vibration\", \"value\":